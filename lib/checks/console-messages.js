/**
 * @fileoverview Health check for console messages captured during spec-up-t operations
 * 
 * This check reads the `.cache/console-messages.json` file generated by spec-up-t's
 * message collector during menu operations [1] (render) and [4] (collect external references).
 * It analyzes the captured messages for errors, warnings, and other issues.
 * 
 * The check provides insights into:
 * - Errors that occurred during operations
 * - Warnings that may indicate potential issues
 * - Operation success rate
 * - Message statistics and patterns
 * 
 * @module checks/console-messages
 */

/**
 * Analyzes console messages captured from spec-up-t operations
 * 
 * This function reads the console messages JSON file and provides detailed
 * analysis of any errors, warnings, or issues found during render or
 * external reference collection operations.
 * 
 * @param {Object} provider - File system provider for accessing project files
 * @param {Object} [options={}] - Check options
 * @param {boolean} [options.verbose=false] - Include all messages in details
 * @returns {Promise<Object>} Health check result with console message analysis
 * 
 * @example
 * const result = await checkConsoleMessages(provider);
 * console.log(`Status: ${result.status}`);
 * console.log(`Errors found: ${result.details.errorCount}`);
 */
export async function checkConsoleMessages(provider, options = {}) {
    const checkName = 'console-messages';
    const messagePath = '.cache/console-messages.json';
    
    try {
        // Check if the console messages file exists
        const fileExists = await provider.fileExists(messagePath);
        
        if (!fileExists) {
            return {
                check: checkName,
                status: 'skip',
                message: 'Console messages file not found. Run "npm run render" or "npm run collectExternalReferences" to generate it.',
                timestamp: new Date().toISOString(),
                details: {
                    path: messagePath,
                    fileExists: false,
                    suggestion: 'Console message collection is available after running menu operations [1] or [4].'
                }
            };
        }
        
        // Read and parse the console messages file
        const content = await provider.readFile(messagePath);
        let consoleData;
        
        try {
            consoleData = JSON.parse(content);
        } catch (parseError) {
            return {
                check: checkName,
                status: 'fail',
                message: 'Failed to parse console messages file',
                timestamp: new Date().toISOString(),
                details: {
                    path: messagePath,
                    error: parseError.message,
                    fileExists: true
                }
            };
        }
        
        // Extract metadata and messages
        const metadata = consoleData.metadata || {};
        const messages = consoleData.messages || [];
        
        // Analyze messages by type
        const errorMessages = messages.filter(m => m.type === 'error');
        const warningMessages = messages.filter(m => m.type === 'warn');
        const successMessages = messages.filter(m => m.type === 'success');
        
        // Determine status based on message analysis
        let status;
        let message;
        
        if (errorMessages.length > 0) {
            status = 'fail';
            message = `Found ${errorMessages.length} error(s) in console output`;
        } else if (warningMessages.length > 0) {
            status = 'warn';
            message = `Found ${warningMessages.length} warning(s) in console output`;
        } else if (messages.length === 0) {
            status = 'skip';
            message = 'No console messages captured (file is empty)';
        } else {
            status = 'pass';
            message = `Console output looks healthy (${successMessages.length} successful operations)`;
        }
        
        // Build detailed information
        const details = {
            path: messagePath,
            fileExists: true,
            metadata: {
                generatedAt: metadata.generatedAt,
                totalMessages: metadata.totalMessages || 0,
                operations: metadata.operations || [],
                messagesByType: metadata.messagesByType || {}
            },
            analysis: {
                errorCount: errorMessages.length,
                warningCount: warningMessages.length,
                successCount: successMessages.length,
                totalMessages: messages.length
            },
            // Include ALL errors (no truncation)
            errors: errorMessages.map(m => ({
                timestamp: m.timestamp,
                message: m.message,
                operation: m.operation,
                additionalData: m.additionalData
            })),
            warnings: warningMessages.slice(0, 10).map(m => ({
                timestamp: m.timestamp,
                message: m.message,
                operation: m.operation,
                additionalData: m.additionalData
            }))
        };
        
        // Include all messages for display in HTML report
        // This allows users to see the complete console output in a table format
        // Always include all messages (regardless of status) so users can see full context
        details.allMessages = messages;
        
        // Add truncation notice only for warnings (errors are never truncated)
        if (warningMessages.length > 10) {
            details.warningsNote = `Showing first 10 of ${warningMessages.length} warnings`;
        }
        
        return {
            check: checkName,
            status,
            message,
            timestamp: new Date().toISOString(),
            details
        };
        
    } catch (error) {
        return {
            check: checkName,
            status: 'fail',
            message: `Failed to check console messages: ${error.message}`,
            timestamp: new Date().toISOString(),
            details: {
                path: messagePath,
                error: error.message,
                stack: error.stack
            }
        };
    }
}

/**
 * Get statistics from console messages without performing a full check
 * 
 * This is a utility function for quickly accessing message statistics
 * without running the full health check.
 * 
 * @param {Object} provider - File system provider
 * @returns {Promise<Object|null>} Statistics object or null if file doesn't exist
 */
export async function getConsoleMessageStats(provider) {
    const messagePath = '.cache/console-messages.json';
    
    try {
        const fileExists = await provider.fileExists(messagePath);
        if (!fileExists) {
            return null;
        }
        
        const content = await provider.readFile(messagePath);
        const consoleData = JSON.parse(content);
        const messages = consoleData.messages || [];
        
        return {
            total: messages.length,
            errors: messages.filter(m => m.type === 'error').length,
            warnings: messages.filter(m => m.type === 'warn').length,
            successes: messages.filter(m => m.type === 'success').length,
            operations: [...new Set(messages.map(m => m.operation).filter(Boolean))],
            generatedAt: consoleData.metadata?.generatedAt
        };
    } catch (error) {
        return null;
    }
}

/**
 * Check metadata for this health check
 */
export const checkConsoleMessagesMetadata = {
    id: 'console-messages',
    name: 'Console Messages',
    description: 'Analyzes console output captured during spec-up-t operations',
    category: 'operations',
    tags: ['console', 'messages', 'errors', 'warnings', 'operations']
};
